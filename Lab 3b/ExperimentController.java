import java.util.*;


/**
 * A class to perform the experiments with timing of random number generation,
 * sorting and search.
 * 
 * @author Ivan Evtimov
 */
public class ExperimentController{
  //constants
  
  //fields
  
  //constructor
    
  //methods
  
  /** 
   * 
   * This method performs a set of commands and return the time taken to 
   * generate and add a series of random numbers between 1 and 2000 to a container
   * 
   * It creates an instance of the Dice() class and and instance of the 
   * RandomIntContainer() class. Each time when a number is generated by Dice,
   * it is stored in RandomIntContainer. It takes the number of items to be generated
   * as a paramater as well as the seed for the Dice.
   * 
   * @param numberOfItems indicates how many times the dice should be called to generate a 
   * number that will be stored in the RandomIntContainer
   * @param seed the seed 
   * @return time to perform commands in milliseconds
   */
  public long timeAddFromFront(int numberOfItems, int seed){
    
        
    //create a RandomIntContainer with the specified number of items
    RandomIntContainer container = new RandomIntContainer(numberOfItems);
    
    //create a Dice with the specified seed
    Dice dice = new Dice(seed);
    
    //record the start time of the loop
    long startTime = System.currentTimeMillis();
    
    //"roll the dice" the specified number of times 
    //and record the result in the container each time
    for (int i = 0; i<numberOfItems; i++){
    
      //upon each roll, record the result in the container
      container.addFromFront(dice.roll());
    
    }
    
    //record the end time of the loop
    long endTime = System.currentTimeMillis();
  
  
    return endTime - startTime;
  }

  /** 
   * 
   * This method returns the time taken to 
   * generate, add, and sort a series of random numbers 
   * between 1 and 2000 to a container.
   * 
   * It creates an instance of the Dice() class and and instance of the 
   * RandomIntSelectionSortContainer() class. Each time when a number is generated by Dice,
   * it is stored in RandomIntContainer. Then the items in the container are sorted using
   * selection sort.
   * The method takes the number of items to be generated
   * as a paramater as well as the seed for the Dice.
   * 
   * @param numberOfItems indicates how many times the dice should be called to generate a 
   * number that will be stored in the RandomIntContainer
   * @param seed the seed 
   * @return time to perform commands in milliseconds
   */
  public long timeAddToFrontSelectionSort(int numberOfItems, int seed){
    
       
    RandomIntSelectionSortContainer randContainer = new RandomIntSelectionSortContainer(numberOfItems);
    
    //create a Dice with the specified seed
    Dice dice = new Dice(seed);
    
    //record the start time of the loop
    long startTime = System.currentTimeMillis();
    
    //"roll the dice" the specified number of times 
    //and record the result in the container each time
    for (int i = 0; i<numberOfItems; i++){
    
      //upon each roll, record the result in the container...
      randContainer.addFromFront(dice.roll());
      //... and sort the stored values
      randContainer.sort();
    
    }
    
    //record the end time of the loop
    long endTime = System.currentTimeMillis();
  
  
    return endTime - startTime;
  }
  

  /** 
   * 
   * This method returns the time taken to 
   * generate, add, and sort a series of random numbers 
   * between 1 and 2000 to a container.
   * 
   * It creates an instance of the Dice() class and and instance of the 
   * RandomIntSelectionSortContainer() class. Each time when a number is generated by Dice,
   * it is stored in RandomIntContainer. Then the items in the container are sorted using
   * insertion sort.
   * The method takes the number of items to be generated
   * as a paramater as well as the seed for the Dice.
   * 
   * @param numberOfItems indicates how many times the dice should be called to generate a 
   * number that will be stored in the RandomIntContainer
   * @param seed the seed 
   * @return time to perform commands in milliseconds
   */
  public long timeAddToFrontInsertionSort(int numberOfItems, int seed){
    
       
    RandomIntInsertionSortContainer randContainer = new RandomIntInsertionSortContainer(numberOfItems);
    
    //create a Dice with the specified seed
    Dice dice = new Dice(seed);
    
    //record the start time of the loop
    long startTime = System.currentTimeMillis();
    
    //"roll the dice" the specified number of times 
    //and record the result in the container each time
    for (int i = 0; i<numberOfItems; i++){
    
      //upon each roll, record the result in the container...
      randContainer.addFromFront(dice.roll());
      //... and sort the stored values
      randContainer.sort();
    
    }
    
    //record the end time of then  loop
    long endTime = System.currentTimeMillis();
  
  
    return endTime - startTime;
  }
  
  
  /**
   * 
   * Main method is where the experiment is actually run.
   * The experiment is set up in 3 stages:
   * first with multiples of 1000, then with multiples of 10000, 
   * and finally with multiples of 100000.
   * Each time, the selection sort is called first and then the insertion sort.
   * The main method takes the seed of the Dice() as a parameter, so that the experiment
   * can be run with multiple different seeds from the command line 
   * without having to recompile each time.
   * 
   */
  public static void main(String[] args){
    
    //////////////////set up experiments//////////////////////
    ExperimentController ec = new ExperimentController();
 
    int seed = Integer.parseInt(args[0]);
    
    
    ////////////////start of experiments//////////////////////////
    //print out the seed that we are using
    System.out.println("The seed is:" + args[0]);

    //////Experiment 1: Multiples of 1000//////////
    //print out a message saying what experiment we're running
    System.out.println("Selection sort with multiples of 1,000:");  
    
    //Selection sort experiment with multiples of 1000
    for (int i = 1;
         i<10;
         i++){
           System.out.println(ec.timeAddToFrontSelectionSort(i*1000, seed));
         }
         
    
    //print out a message saying what experiment we're running
    System.out.println("Insertion sort with multiples of 1,000:");
    
    //Insertion sort experiment with multiples of 1000
    for (int i = 1;
         i<10;
         i++){
           System.out.println(ec.timeAddToFrontInsertionSort(i*1000, seed));
         }
   
    //////Experiment 2: Multiples of 10,000//////////
    //print out a message saying what experiment we're running
    System.out.println("Selection sort with multiples of 10,000:"); 

    //Selection sort experiment with multiples of 10000
    for (int i = 1;
         i<10;
         i++){
           System.out.println(ec.timeAddToFrontSelectionSort(i*10000, seed));
         }
         
    //print out a message saying what experiment we're running
    System.out.println("Insertion sort with multiples of 10,000:"); 

    //Insertion sort experiment with multiples of 10000
    for (int i = 1;
         i<10;
         i++){
           System.out.println(ec.timeAddToFrontInsertionSort(i*10000, seed));
         }

    
    //////Experiment 3: Multiples of 100,000//////////
    //print out a message saying what experiment we're running
    System.out.println("Selection sort with multiples of 100,000:"); 

    //Selection sort experiment with multiples of 100,000
    for (int i = 1;
         i<11;
         i++){
           System.out.println(ec.timeAddToFrontSelectionSort(i*100000, seed));
         }

    //print out a message saying what experiment we're running
    System.out.println("Insertion sort with multiples of 100,000:"); 

    //Insertion sort experiment with multiples of 100,000
    for (int i = 1;
         i<11;
         i++){
           System.out.println(ec.timeAddToFrontInsertionSort(i*100000, seed));
         }
         
         
  //////////////////end of experiments and end of main method//////////////////
                       
 }
}
               
